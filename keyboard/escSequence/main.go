/*
escSequence is a tool that builds a radix tree for interpreting multi-key
keypress sequences. Such sequences (prefixed with Escape, hence the name of the
tool) are presented on a process's stdin when the terminal is in raw mode and
the user presses a special key.

TODO: could have two input files, one to generate escape sequences and one for
just plain special keys (escape/enter/backspace etc.).
*/
package main

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"sort"
	"strings"
	"unicode/utf8"
)

const (
	progName = "escSequence"
)

// this is similar to the keyboard.tree structure except that we store the key
// name symbolically rather than as an integer. Only one of keyName or c may
// have a value.
type tree struct {
	keyName string
	c       map[uint8]*tree
}

func treeAddAux(t *tree, uniq map[string]bool, seq, name string) error {
	if uniq[name] {
		return fmt.Errorf("duplicate key name %q", name)
	}
	uniq[name] = true

	n := len(seq)
	for i := 0; i < n; i++ {
		if t.keyName != "" {
			return fmt.Errorf("sequence prefix %q maps to key %q",
				seq[:i], t.keyName)
		}

		if t.c == nil {
			t.c = make(map[uint8]*tree)
		}

		tc := t.c[seq[i]]
		if tc == nil {
			tc = &tree{}
			t.c[seq[i]] = tc
		}
		t = tc
	}
	t.keyName = name
	return nil
}

func treeAdd(t *tree, uniq map[string]bool, ln string) error {
	// strip comments and trailing/leading whitespace
	idx := strings.IndexRune(ln, '#')
	if idx != -1 {
		ln = ln[:idx]
	}
	ln = strings.TrimSpace(ln)

	// ignore blank lines
	if ln == "" {
		return nil
	}

	// we should have <Sequence>,<Name>
	toks := strings.Fields(ln)
	if len(toks) != 2 {
		return errors.New("only expecting two tokens")
	}

	return treeAddAux(t, uniq, toks[0], toks[1])
}

// treeAddRunes adds a range of predictable sequences to the tree
func treeAddRunes(t *tree, uniq map[string]bool, rBegin, rEnd rune) error {
	for r := rBegin; r <= rEnd; r++ {
		seq := fmt.Sprintf("%c", r)
		name := fmt.Sprintf("Alt_%c", r)
		err := treeAddAux(t, uniq, seq, name)
		if err != nil {
			return err
		}
	}
	return nil
}

// treeAddRuneLists programatically adds certain predictable sequences to the
// tree, so we don't have to list them all by hand in the input file
func treeAddRuneLists(t *tree, keyNames map[string]bool) error {
	if err := treeAddRunes(t, keyNames, '0', '9'); err != nil {
		return err
	}

	if err := treeAddRunes(t, keyNames, 'A', 'N'); err != nil {
		return err
	}
	// NB: 'O' is omitted because it collides with F1â€“F4
	if err := treeAddRunes(t, keyNames, 'P', 'Z'); err != nil {
		return err
	}

	if err := treeAddRunes(t, keyNames, 'a', 'z'); err != nil {
		return err
	}
	return nil
}

// treeDumpAux is a recursive function to dump out the child nodes of any entry
// in the radix tree
func treeDumpAux(seq []uint8, t *tree) {
	n := len(seq)
	indent := strings.Repeat("\t", 2*n)

	fmt.Printf("%s'%c': &tree{\n", indent, seq[len(seq)-1])
	if t.keyName != "" {
		// leaf node: set the keypress value corresponding to the
		// sequence we traversed to arrive here
		fmt.Printf("%s\tkp: Key_%s,\n", indent, t.keyName)

	} else {
		// intermediate node: dump the mapping between keys and child
		// nodes (see treeDump() for explanation of list and sorting)
		fmt.Printf("%s\tc: map[uint8]*tree{\n", indent)
		seq = seq[:n+1]

		keys := make([]int, len(t.c))
		idx := 0
		for k := range t.c {
			keys[idx] = int(k)
			idx++
		}
		sort.Ints(keys)
		for _, k := range keys {
			seq[n] = uint8(k)
			treeDumpAux(seq, t.c[uint8(k)])
		}
		fmt.Printf("%s\t},\n", indent)
	}
	fmt.Printf("%s},\n", indent)
}

// treeDump prints out the radix tree data structure used to interpret keypress
// sequences
func treeDump(t *tree) {
	seq := make([]uint8, 1, 20)

	fmt.Print("\nvar seqMap = &tree{\n")
	fmt.Print("\tc: map[uint8]*tree{\n")

	// we want to sort children based on character so prepare a list of
	// characters and sort it. If we just used map iteration we would end
	// up with an unsorted list in arbitrary order.
	keys := make([]int, len(t.c))
	idx := 0
	for k := range t.c {
		keys[idx] = int(k)
		idx++
	}
	sort.Ints(keys)

	// recursively dump the children of the first node
	for _, k := range keys {
		seq[0] = uint8(k)
		treeDumpAux(seq, t.c[uint8(k)])
	}
	fmt.Print("\t},\n}\n")
}

// constDumpKey prints a single entry for the map generated by constDump.
func constDumpKey(k string, maxlen int) {
	klen := utf8.RuneCountInString(k)
	fmt.Printf("\tKey_%s:%s %q,\n", k, strings.Repeat(" ", maxlen-klen), k)
}

// constDump prints out the keypress constants defined by our input list
// (Key_*, numbered from -1000 downwards) and prints a map which can turn a
// key constant into a human-readable string (including for some predefined
// special keys not listed in the normal file).
func constDump(keyNames map[string]bool) {
	fmt.Print("\nconst (\n")

	// We want to print the lists sorted lexically by key name. If we were
	// to use map iteration we would end up with an aribtrary, unsorted list
	// so we prepare a list of key names ourselves and sort it.
	names := make([]string, len(keyNames))
	idx := 0
	for k, _ := range keyNames {
		names[idx] = k
		idx++
	}
	sort.Strings(names)

	// print out our numeric keypress constants; we'll also want the max
	// string length so we can nicely justify our map in the following
	// section
	maxlen := 0
	for idx, k := range names {
		klen := utf8.RuneCountInString(k)
		if klen > maxlen {
			maxlen = klen
		}

		if idx == 0 {
			fmt.Printf("\tKey_%s KeyPress = -1000 - iota\n", k)
		} else {
			fmt.Printf("\tKey_%s\n", k)
		}
	}

	fmt.Print(")\n\nvar KeyNames = map[KeyPress]string{\n")

	// print mapping between keypress constants and key names. HACK: we add
	// some special hardcoded sequences manually
	constDumpKey("Escape", maxlen)
	constDumpKey("Enter", maxlen)
	constDumpKey("Backspace", maxlen)
	for _, k := range names {
		constDumpKey(k, maxlen)
	}
	fmt.Print("}\n")
}

func main() {
	t := &tree{}
	keyNames := make(map[string]bool)

	// read lines from stdin, passing each to treeAdd (which will skip
	// blanks) in order to populate the escape sequence tree
	lncount := 0
	buf := bufio.NewReader(os.Stdin)
	for ln, err := buf.ReadString('\n'); err == nil; ln, err = buf.ReadString('\n') {
		lncount++
		err = treeAdd(t, keyNames, ln)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s: invalid line %d %q: %s\n",
				progName, lncount, ln, err.Error())
			os.Exit(1)
		}
	}

	// alt+<key> results in <esc>+<key> being received, so we can add a
	// bunch of these programatically
	err := treeAddRuneLists(t, keyNames)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s: error adding built-in key: %s\n",
			progName, err.Error())
		os.Exit(1)
	}

	fmt.Print(`package keyboard

/*
DO NOT EDIT
	This file has been automatically generated by the escSequence tool. Any
	changes made will be lost.
*/
`)
	constDump(keyNames)
	treeDump(t)
}
